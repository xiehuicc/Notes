### 1.commonJS模块化

#### 1.1模块化加载过程

- **结论一：**模块在被第一次引入时，模块中的js代码会被执行一次

- **结论二：** 模块被多次引用，会缓存，最终只加载一次

  - 因为每个模块对象module都有一个属性：loaded
  - 为false时，表示还未加载，true为已加载

- **结论三：** 如果有模块之间循环引用，加载顺序是什么？

  - 这其实是一个数据结构：图结构；Node采用的是图的深度遍历优先

  

#### 1.2commonJS规范的缺点

- CommonJs加载模块是 **同步的**
  - 同步意味着只有等待对应模块加载完毕，当前模块的内容才会被运行
  - 服务器中加载js文件都是本地文件，加载速度非常快
- 如果将它运用于浏览器呢
  - 浏览器加载js文件需要先从服务器将文件下载下来，之后在本地运行
  - 采用同步就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作
  - 所以**浏览器中通常不适用commonJS**（webpack除外，因为它会将代码转为浏览器可以直接执行的代码），而是使用ES Module



### 2.ES Module

#### 2.1 export和import结合使用

补充：export和import可以结合使用

```js
export { sum as barsum} from './bar.js'
```

原因：

- 在开发和封装一个功能库（第三方库），通常我们希望将暴露的所有接口放在一个文件中
  - 这样方便指定统一的接口规范，也方便阅读



#### 2.2 default的用法

- export是有名字的导出
  - 在导出export时指定了名字
  - 在导入import时，需要知道具体的名字
- 还有一种导出叫默认导出default
  - 默认导出export时，不需要指定名字
  - 在导入时不需要使用{}，并且可以自己来指定名字
  - 方便和我们现有的CommonJs等规范进行操作
- 注意：一个模块只能有一个默认导出（default export）




### 3.CommonJS和ES Module之间的调用

- **结论一：** 通常情况下，CommonJS不能加载ES Module
  -  因为CommonJs是同步加载的，但是ES Module 必须经过静态分析（先把文件下载下来，再对文件进行分析）等，无法在这个时候执行JavaScript代码
  -  但是并非绝对，某些平台在实现时可以对代码进行针对性解析，也可能支持
  -  Node中不支持
- **结论二：** 多数情况下，ES Module 可以加载CommonJS
  - ES Module在加载CommonJS时，会将其module.exports导出的内容作为default导出方式来使用
  - webpack中是支持的，Node最新版本也是支持的
  
    

