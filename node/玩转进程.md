> 一个node进程只能利用一个核，这将抛出Node实际应用的一个问题，如何充分利用多核CPU服务器？
>
> 另外，由于Node执行在单线程上，一旦线程抛出的异常没有捕获，这将引起整个进程的崩溃。这给Node实际应用抛出了第二个问题：如何保证进程的健壮性和稳定性？

### 1.服务模型的变迁

#### 1.1 石器时代：同步

#### 1.2青铜时代：复制进程

#### 1.3白银时代：多线程

#### 1.4黄金时代：事件驱动

### 2.多进程架构

#### 2.1 创建子进程

child_process模块给予Node可以随意创建子进程（child_process）的能力。它提供了4个方法用于创建子进程

- spawn()：启动一个子进程来执行命令。
- exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，他有一个回调函数获知子进程的状况。适合执行已有的命令。
- execFile()：启动一个子进程来执行可执行文件，适合执行文件。
- fork()：与spawn()类似，不同点在于它创建的Node子进程只需要指定需要执行的JavaScript文件模块即可。

spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程运行超过设定时间就会被杀死。

#### 2.2 进程间通信

在Master-Worker（主从模式），要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。对于child_process模块，创建好了子进程，然后与父子进程间通信是十分容易的。

主线程和工作线程之间通过onmessage()和postMessage()进行通信，子进程对象则由send()方法实现主进程向子进程发送数据。